			            PSEUDOCODE :ZENSMARTBLOX

All the mapping are stored in connection registry.
	
Application-dev.properties.java

	nodeEndpoint=
	nodeEndPointIPFS=
	contractAddress=


// Get Web3 node connection:

public Web3J getWeb3Connection(String nodeEndpoint)
{
// Connecting to end point present in connection registry.
return Web3j.build(new HttpService(nodeEndpoint));
 
}





// Get Parity connection:

public Parity getParityConnection(String nodeEndpoint)
{
     return Parity.build(new HttpService(nodeEndpoint));
}





// Smart contract Generation:
We first need to create smart contract wrapper 
# Creating smart contract wrapper:

org.web3j.codegen.SolidityFunctionWrapperGenerator /path/to/<smart-contract>.bin /path/to/<smart-contract>.abi -o /path/to/src/main/java -p com.your.organisation.name





# Deploying Smart contract

public contractDeployment getContractAddress()
{
// Load the credentials from a wallet file
Credentials credentials = WalletUtils.loadCredentials("password", "/path/to/walletfile"); 
 
// Provide values of gas price,gas limit and values
YourSmartContract contract = YourSmartContract.deploy(<web3j>, <credentials>,GAS_PRICE, GAS_LIMIT,<initialEtherValue>).get(); 
 
//Returns address of contract
    return contract;   
}



# Loading Smart contract
public fetchContractDetails()
{   
//Loading smart contract from connection registry
YourSmartContract contract = YourSmartContract.load("contractAddress", <web3j>, <credentials>, GAS_PRICE, GAS_LIMIT);

}



// Transaction:

# creating Raw transaction:
public transactionHash getRawTransaction(){

//Providing nonce,gas price,gas limit,to address and value to be transferred 
RawTransaction rawTransaction  = RawTransaction.createEtherTransaction(nonce, <gas price>, <gas limit>, <toAddress>, <value>); 

//Signing of Transaction
byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, <credentials>); 

//Return hex string
String hexValue = Numeric.toHexString(signedMessage); 

//Sending transaction
EthSendTransaction ethSendTransaction = web3j.ethSendRawTransaction(hexValue).sendAsync().get(); 
//Generation of transaction hash
String transactionHash = ethSendTransaction.getTransactionHash(); 
return transactionHash;
}





# Creating ether transaction:
public transactionHash getTransactionHash(){

//Providing nonce,gas price,gas limit,from address,to address and value to be transferred 
Transaction transaction = Transaction.createEtherTransaction(fromAddress, nonce, gasPrice, gasLimit, toAddress,amount);

//Sending transaction:
EthSendTransaction ethSendTransaction = web3.ethSendTransaction(transaction).send();

//Creating Transaction hash:
String transactionHash = ethSendTransaction.getTransactionHash();

return transactionHash;
}



// IPFS :

// This method is used to get the file from IPFS server.
public Docs getDocIPFSPath(requestId, requestType) {

//Connecting to IPFS node
IPFS ipfs = new IPFS(nodeEndPointIPFS);
 
//Entering the file details to be stored in IPFS
NamedStreamable.FileWrapper file = new NamedStreamable.FileWrapper(new            File("Absolute_Filepath"));
 
//Adding file details to IPFS node
MerkleNode addResult = ipfs.add(file);
 

//Getting hash of IPFS file path
return  addResult.hash;
 
//Using IPFS file hash to open its contents
Multihash filePointer = MultihashfromBase58(addResult.hash);
byte[] fileContents = ipfs.cat(filePointer);
FileOutputStream fileOS=new FileOutputStream(new File("Absolute_Filepath"));
 
//Writting contents to file
fileOS.write(fileContents);

//Closing the file
fileOS.close();

}





// SECURITY:

At Senders side we would be doing raw transaction and sending signed hex value.
Senders side:


// Create a raw transaction
RawTransaction rawTransaction  = RawTransaction.createEtherTransaction(nonce, <gas price>, <gas limit>, <toAddress>, <value>); 
 
// Sign the sign traansaction inturn it  returns the signed hex value .
byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, <credentials>); 

//Returns hex string
String hexValue = Numeric.toHexString(signedMessage); 

//Sending transaction
EthSendTransaction ethSendTransaction = web3j.ethSendRawTransaction(hexValue).sendAsync().get(); 

//Generation of transaction hash
String transactionHash = ethSendTransaction.getTransactionHash(); 
return transactionHash;

//creating hashofhash(encrypting) to be send at receivers side for decryption
String RANDOM=result.toString()+hexValue+result1.toString();
 
//An example of HashOfHash       
hMXSHhkf865438504a817c80083033450945cba18cce01145eb24839328cf464bf37c433a1464801ca068c3d289ee1839d29f9bbd81a0cc552cf736da8d816e4a93317184216319ce64a00879b6e0ec663e91fb4b311e5ee8e5cfe2ed4c66551c0c718111aa888acb572ebB0JO1R206sLYqDRul7a0BTU48
hash0xe946cfa05d31fa7b2ee09538ab5dd6a025ca516d784ade1bdf406c22b2828b66

Receivers side:

//Decrypt the hex string
 
//Use the hex string to test for valid transaction:
byte[] rawtx = Hex.decode(RANDOM2.getBytes());
Transaction tx = new Transaction(rawtx);
return hash;



// Generating Ledger:

blocknumber=web3.ethBlockNumber().send().getBlockNumber();
Map<String, String> mapVal=new HashMap<>();
List<TransactionObject> listTxnObject=null;
List<String> dateStringList=new ArrayList<>();
Map<String,List<TransactionObject>> mapTxn=new HashMap<>();
for(int i=intBlockNumber;i>currentBlockNumber;i--)
{    
// Get latest block by block number      
EthBlocklatestBlock=web3.ethGetBlockByNumber(DefaultBlockParameter.valueOf(blocknumberBigInt),true).send();
 
//Get timestamp
SimpleDateFormat sdf = new SimpleDateFormat("yy-MM-dd HH:mm:ssz"); 
 
// Format of your date
String formattedDate = sdf.format(date);
 
listTxnObject=new ArrayList<>();
//Fetch Transaction count
   transactionsCount=latestBlock.getBlock().getTransactions().size();
 
// Checking for condition
if(transactionsCount > 0)
{  
List<TransactionResult>  tr= latestBlock.getBlock().getTransactions();
Iterator<TransactionResult> itr=tr.iterator();
while(itr.hasNext())
{
TransactionObject trObj=(TransactionObject)itr.next();
listTxnObject.add(trObj);  
}
//No date for txn. Instead date and time of block need to refer
if(listTxnObject.size() > 0)
mapTransactions.put(formattedDate, listTxnObject);
}
}
}


 
 
 
Solidity contract :
For saving,updating and fetching:

pragma solidity ^0.4.0;

//Importing Required libraries 
import "github.com/ethereum/*;

//Naming contract
contract BrokerRequestStatus {
using strings for *;

// Declaring variables
variable valreqids;
variable cities;
variable saveDashboardDeatils;
variables status;

variable comma = ",";
variable scolon = ";";
variable  finalstr;

//saving data in smart contract based on index
function saveDetails(valuationRequestId,city,statusDesc) public returns(String)
{
    
    var valreq  = valreqids[index].toSlice().concat(comma.toSlice());
    var cit = cities[index].toSlice().concat(comma.toSlice());
    var stat = status[index];

    var combine = valreq.toSlice().concat(cit.toSlice());
    
    var finalstr = combine.toSlice().concat(stat.toSlice());
    
    saveDashboardDeatils[index] = finalstr;
    return finalstr;
}

//Updating values in smart contract based on index
function updateRequestStatus(index,RequestId,city,latestStatus) public returns (String)
{


            var valreq  = valreqids[index].toSlice().concat(comma.toSlice());
            var cit = cities[index].toSlice().concat(comma.toSlice());
            var stat = status[index];

            var combine = valreq.toSlice().concat(cit.toSlice());
    
            var finalstr = combine.toSlice().concat(stat.toSlice());
    
            saveDashboardDeatils[index] = finalstr;        
       

     return finalstr;
    
  }
  
  //Fetching values stored in smart contract
  function fetchRequestStatus(uint index) public constant returns(string)
  {
      return saveDashboardDeatils[index] ;
  }
}


